[
  {
    "objectID": "advanced.html",
    "href": "advanced.html",
    "title": "Shiny Express: Advanced topics",
    "section": "",
    "text": "Note\n\n\n\nThis document was written and updated during the development of Shiny Express, and some parts of it may now be out of date.\nPlease see the official documentation for Shiny Express.\n\n\nShiny Express is built on top of “Core” Shiny – everything that you can do with Shiny Express you can also do in Shiny Core. The reverse isn’t exactly true – there are times where you’ll hit the limits of Shiny Express and need to use Shiny Core.\nThis document explains some of the technical details behind how Shiny Express works. Most Shiny Express users don’t need to read this document, but if you want to understand how it works under the hood, or want to do something more sophisticated with Shiny Express, you might find this document useful.\n\n\n\n\n\n\nNote\n\n\n\nThis page is still a work in progress, and some sections are not yet complete!\n\n\n\nSpecial evaluation of Shiny Express app code\nIn a Shiny Core app, when you run shiny run app.py from the command line, it effectively runs the Python code in app.py. In that code, you must create an object named app, which is a Shiny.App object. That object also conforms to the ASGI application specification, which means that it is a web application that can be run by an ASGI web server. For Shiny, we use uvicorn as the web server.\nIn a Shiny Express app, you do not explicitly create an object named app; you actually do not create a Shiny.App object anywhere. That is done automatically for you, when Shiny detects that it is a Shiny Express app.\nHow does Shiny detect when the app is an Express app? When you call shiny run app.py, it parses the code and looks for an import statement like these at the top level of the code. If it contains one of these, then Shiny knows that it’s an Express app, and evaluates the code in a special way, which we’ll talk about more below.\n# Any of these imports indicates that it is a Shiny Express app\nimport shiny.express\nfrom shiny import express\nfrom shiny.express import input\nNext: - special evaluation to capture side effects - create app object\n\n\nSpecial evaluation of Express app code: UI as display\nAs mentioned above, the code of an Express app is evaluated in a special way. This is needed because the code needs to be evaluated in a way that is similar to Jupyter notebooks: in a Jupyter notebook, the results of most top-level statements are rendered in the notebook. Jupyter does this by evaluating each statement and calling IPython.display.display() on the return value. In Shiny Express, we need to do something similar.\nBefore diving into Shiny Express, let’s talk about how Shiny Core works. In Shiny Core, you create UI by calling pure functions that return objects. Containership is expressed by passing children as arguments into the parent when the latter is being created. Eventually, the top-level parent is passed to Shiny via the App object (or returned from a @render.ui).\n# Shiny Core\napp_ui = ui.page_fixed(\n    widget1(),\n    widget2(),\n    widget3(),\n)\n\napp = App(app_ui, ...)\nIn Shiny Express, top-level statements are evaluated in order, and any non-None expression has something like Jupyter’s display() called on it. This is intended to feel similar to a code chunk in .rmd or .qmd, or like a Jupyter notebook (with InteractiveShell.ast_node_interactivity=\"all\").\n# Shiny Express\nwidget1()       # Displayed\nw2 = widget2()  # Not displayed\nw2              # Now it's displayed\nwidget3()       # Displayed\nShiny Express does not actually call IPython.display.display() on each statement. Instead, it collects the result of each statement.\nThere’s an inherent tension in these decisions. What seems to be the case is that from a superficial level, imperative UI feels more intuitive than functional UI–that is, calling button() should immediately “output” a button at the moment it’s called, rather than returning some kind of value. And indeed, there are UI frameworks that take this approach, including Streamlit.\nBut imperative UI starts to run into trouble very quickly, because programming against side-effects is harder than programming against values. For example, consider a function that takes a title as an argument, which could either be a string or an HTML element. How would you pass an HTML element if the very act of constructing an &lt;h1&gt; causes it to be emitted as output? Or think about a function that takes a while to generate some UI; if UI is just returned objects, you can trivially cache the results in any number of naturally Pythonic ways, but if it’s side effects, you have to figure out some way of intercepting those side effects, and cache them using some custom mechanism.\nThe display() approach of Jupyter/Quarto/Express serves as a compromise between Shiny Core’s functional approach and Streamlit’s imperative approach. The code looks very similar to imperative code, but we’re able to re-use most of our UI components even though they use the pure functional style. (Existing container components cannot be used in Express, as explained in the next section.)\nOne special challenge is dealing with expressions that are not at the top-level; that is, in functions. If you define a function in a Quarto code chunk or Jupyter notebook cell, its expressions will not be displayed/printed. The same is true in Shiny Express. However, it’s clearly desirable to be able to write functions that express UI, and it’d be great to do it without having to explicitly call sys.displayhook() on every piece of UI. The @expressify decorator does this by transforming a function’s body to behave like the top level (and see also @render.express, which is sort of like @render.ui plus @expressify combined).\n\nExpress advantages:\n\nSame/similar paradigm as Quarto chunk or Jupyter notebook cell.\nFewer commas/parentheses.\n\n\n\nCore advantages:\n\nEasier refactoring of complicated UI (extracting into variables, parameterized functions, caching, etc.).\nCan write apps in Python modules/packages.\n\n\n\n\nContainers as context managers\nThe prior two differences make container components a special challenge for Shiny Express. Shiny Core’s UI components are passed as function arguments, but Shiny Express’s render functions make this approach untenable; Python won’t let you declare a decorated function and pass it as a function argument at the same time.\nAs a result, you can’t use Shiny Core’s container UI functions with Shiny Express. Instead, we’ve created a Shiny Express port for each of our container functions.\nCore syntax:\n# Shiny Core\napp_ui = ui.page_fixed(\n    ui.card(\n        ui.input_slider(),\n        ui.output_plot(\"plot1\"),\n    )\n)\n\ndef server(input, output, session):\n    @render.plot\n    def plot1():\n        ...\n\napp = App(app_ui, server)\nExpress syntax (notice that we don’t need to call page_fixed() because it is the default page type for Express):\n# Shiny Express\nfrom shiny.express import layout\n\nwith layout.card():\n    ui.input_slider()\n\n    @render.plot\n    def plot1():\n        ...\nThese new shiny.express.layout container functions do not return objects, but rather, Python context managers that are side-effecty (they intercept sys.displayhook while inside the with block, and display() themselves upon exit).\n\nExpress advantages:\n\nMakes it possible to put render functions inside UI containers.\nFewer commas/parentheses.\n\n\n\nCore advantages:\n\nAs before, easier refactoring of complicated UI (extracting into variables, parameterized functions, caching, etc.).\nContainer function signatures make it easier to see what arguments are allowed/required.\nNo difference between child and container UI functions, in terms of: how you call them, how you handle their results, and how you write your own.\n\n\n\n\nrender functions automatically create outputs\nIn the Core version of the previous example app, the server function contains a @render.plot; def plot1(), and the UI contains a corresponding output, ui.output_plot(\"plot1\"). The output component is how Shiny Core knows where to put the plot on the page.\n# Shiny Core\napp_ui = ui.page_fixed(\n    ui.card(\n        ui.input_slider(),\n        ui.output_plot(\"plot1\"),\n    )\n)\n\ndef server(input, output, session):\n    @render.plot\n    def plot1():\n        ...\n\napp = App(app_ui, server)\nIn an Express app, you don’t need to explicitly call ui.output_plot(\"plot1\"). Instead, when you call @render.plot; def plot1(), it automatically puts the corresponding output at that location:\n# Shiny Express\nfrom shiny.express import layout\n\nwith layout.card():\n    ui.input_slider()\n\n    @render.plot\n    def plot1():\n        ...\n\n\nPreventing display of objects with ui.hold()\nIf for some reason, you want to create an object but not render it into the page at that location, one way to do it is to simply assign it to a variable:\nx = widget()\nJust like in a Jupyter notebook, assigning the value to a variable prevents it from being displayed in the Shiny app. You can later put x on a line by itself to display it there.\nHowever, there are cases where you can’t do this with Python. If you have a @render.plot, but don’t want it to put an output right there, you can’t assign it to a variable with x = .... This simply is not valid Python code:\n# NOT valid code\nx = @render.plot\ndef _():\n    ...\nFor cases like this, you can use with ui.hold():\nwith ui.hold():\n    @render.plot\n    def plot1():\n        ...\nYou could also put more render functions in that same code block if you wanted.\nYou would have to add the corresponding output explicitly somewhere in your app:\nui.output_plot(\"plot1\", click=True)\nThis can be useful when you want to add an output_plot with options that aren’t available in the render.plot() function. (Although note that in a future version of Shiny, we plan to make all of those options, like click, available in the render.plot() function.)\nYou can also use with ui.hold() as x, and then place x later in the page.\n# Create a card here...\nwith ui.hold() as hello_card:\n    with ui.card():\n        with ui.span():\n            \"This is a\"\n            ui.span(\" card\", style=\"color: red;\")\n\n\nui.h3(\"Some content\")\n\n# and display the card here\nhello_card\n\n\n@render.text() for plain text, @render.code() for code\nWhen @render.text() is used, it defaults to displaying as plain text, and when @render.code() is used, it defaults to displaying in a monospaced font in a code block.\n#| standalone: true\n#| components: [editor, viewer]\n#| layout: vertical\n#| viewerHeight: 300\nfrom shiny.express import render, ui\n\n@render.text\ndef txt():\n    return \"This is @render.text\"\n\nui.br()\n\n@render.code\ndef code():\n    return \"This is @render.code\"\n\n\nUsing Express syntax in functions with @expressify\nIf you want to write a function using Express syntax (as opposed to Core syntax), you can use @expressify. In the example below, you can compare the syntax to the version that’s written with Shiny Core syntax.\n#| standalone: true\n#| components: [editor, viewer]\n#| layout: vertical\n#| viewerHeight: 300\nfrom shiny.express import expressify, ui\n\n# The Shiny Express syntax version\n@expressify\ndef card(i: int):\n    with ui.card():\n        with ui.span():\n            \"This is a card with @expressify: \"\n            ui.span(str(i), style=\"color: red;\")\n\ncard(1)\ncard(2)\n\n\n# The Shiny Core syntax version, with nested function calls\ndef card_core(i: int):\n    from shiny import ui as sui\n\n    return sui.card(\n        sui.span(\n            \"This is a card with Shiny Core: \",\n            sui.span(str(i), style=\"color: blue;\"),\n        )\n    )\n\n\ncard_core(1)\ncard_core(2)\n\n\n@render.express()\n\n\nCode is run twice\n\n\nShared objects\nIn a Shiny Core app, each time a web browser visits the page, Shiny executes the server function once; any objects created inside of the server function (this includes reactive and regular non-reactive objects) are scoped to that user session.\nGlobal objects – those that are created outside of the server function – are shared across all sessions. This is useful if there are slow operations that only need to be done once, like loading a large data set. Sharing large objects can also significantly reduce the memory load of the application.\n# Shiny Core\n\n# Global objects here are shared across all sessions (within a Python process)\ndf = pd.read_csv(\"big_data.csv\")\n\ndef server(input, output, session):\n    # Everything in this function is scoped to each user session\n\n    db_conn = connect(...)\n\n    @render.table\n    def tbl():\n        return df\n\napp = App(app_ui, server)\nIn a Shiny Express app, all of the code in the app.py is run once per session. (There is actually a Shiny server function which evaluates the code within its scope, and like any Shiny server function, it is executed once per user session.) This means that code at the top level of the Shiny Express app file is not shared across sessions.\nIf you want to share objects across Shiny sessions, you can create a separate .py file and put the shared code in there, and then import that file into your app. For example, you could have a file called shared.py with the following:\n\n\nshared.py\n\ndf = pd.read_csv(\"big_data.csv\")\n\nThen your app might look like this:\n\n\napp.py\n\nimport shared\n\n# This is scoped to the session\ndb_conn = connect(...)\n\n@render.table\ndef tbl():\n    return shared.df\n\n(Note that you can’t name the file global.py because global is a reserved keyword in Python, and you can’t use import global in your app.)\nPython’s module loading system is smart, and does not run the code in shared.py each time it is imported. The code in shared.py is run only once, on the first import. The objects in the shared module are then shared – if you modify an object in one Shiny session, that change will also be reflected in other Shiny sessions.\n\nShared reactive objects\nThe example above used a non-reactive object (a data frame) in shared.py. If you have any reactive objects that are in shared.py, then you must create them without an active session. As mentioned earlier, the code in shared.py is run on the first import. In Shiny Express, that first import can happen with an active user session, and that will confuse the reactive graph.\n\n\n\n\nEntrypoint"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Shiny Express: Basics",
    "section": "",
    "text": "Note\n\n\n\nThis document was written and updated during the development of Shiny Express, and some parts of it may now be out of date.\nPlease see the official documentation for Shiny Express.\nShiny Express is a new way of writing Shiny apps that is intended to be easier to learn and quicker to write. We think that writing Shiny Express is comparable to Streamlit in terms of how easily you can create an app, but Shiny Express does not limit you the way that Streamlit does – there is a much higher ceiling to what you can do with Shiny Express.\nShiny Express is still Shiny, just with a simpler syntax."
  },
  {
    "objectID": "index.html#quickstart",
    "href": "index.html#quickstart",
    "title": "Shiny Express: Basics",
    "section": "Quickstart",
    "text": "Quickstart\nThe best way to introduce Shiny Express is by example. Here is a simple “Hello World” app:\n#| standalone: true\n#| components: [editor, viewer]\n#| layout: vertical\n\nfrom shiny import render\nfrom shiny.express import input, ui\n\nui.input_slider(\"n\", \"N\", min=1, max=50, value=30)\n\n@render.code\ndef txt():\n    return f\"Hello! n*2 is {input.n() * 2}.\"\nThe first thing to notice is that ui is imported from shiny.express, as opposed to being imported from shiny.\nThe slider input comes from ui.input_slider(), and the text output is a function that’s decorated with @render.code and returns a string.\nIf you’ve seen traditional Shiny applications (which we’ll now refer to as “Shiny Core” apps), you’ll notice some important differences. Here’s the same app written in Shiny Core form:\n#| standalone: true\n#| components: [editor, viewer]\n#| layout: vertical\nfrom shiny import App, ui, render\n\napp_ui = ui.page_fixed(\n    ui.input_slider(\"n\", \"N\", min=1, max=50, value=30),\n    ui.output_code(\"txt\"),\n)\n\ndef server(input, output, session):\n    @render.code\n    def txt():\n        return f\"Hello! n*2 is {input.n() * 2}.\"\n\napp = App(app_ui, server)\nNot only is there significantly less code in the Express version, but there are fewer concepts to (mis)understand or be intimidated by.\nHere’s what’s different in the Core app:\n\nfrom shiny import ui, instead of from shiny.express import ui.\nThe UI is created explicitly in a variable named app_ui, using nested calls to UI component functions.\nThere is an explicitly defined server function. (This function is executed once for each browser session that connects to the app).\nThe code output is created with output_code(\"txt\"). For Shiny Express mode, we didn’t have to create that output – it’s created automatically when it sees the @render.code.\nThere is an explicitly created object named app, which is a shiny.App() object.\n\nShiny Express apps do these things implicitly, instead of requiring you to do them explicitly."
  },
  {
    "objectID": "index.html#installation",
    "href": "index.html#installation",
    "title": "Shiny Express: Basics",
    "section": "Installation",
    "text": "Installation\nAs of this writing, Shiny Express is in Shiny 0.6.1, which is on PyPI. However, there have been changes to Shiny Express in the development version since then, and this document reflects those changes. It can also be used on shinylive.io. (For embedding Shinylive applications in Quarto documents, it is technically possible, as this document shows, but it is a manual process as of this writing.)\nTo run these examples, you can use shinylive.io, or you can install shiny and htmltools locally:\npip install shiny"
  },
  {
    "objectID": "index.html#basic-app-with-a-plot",
    "href": "index.html#basic-app-with-a-plot",
    "title": "Shiny Express: Basics",
    "section": "Basic app with a plot",
    "text": "Basic app with a plot\nThe example above shows a very bare-bones Shiny application. Here’s one that’s a little more sophisticated, with a container component (a sidebar), and a plot.\n#| standalone: true\n#| components: [editor, viewer]\n#| layout: vertical\n#| viewerHeight: 300\nimport matplotlib.pyplot as plt\nfrom shiny import render\nfrom shiny.express import input, ui\n\nwith ui.sidebar():\n    ui.input_slider(\"n\", \"Number of points\", min=1, max=20, value=10)\n\n@render.plot\ndef plot():\n    plt.scatter(range(input.n()), range(input.n()))\nContrast the Shiny Express code above with the Shiny Core equivalent below:\n#| standalone: true\n#| components: [editor, viewer]\n#| layout: vertical\n#| viewerHeight: 300\nimport matplotlib.pyplot as plt\nfrom shiny import App, ui, render\n\napp_ui = ui.page_sidebar(\n    ui.sidebar(\n        ui.input_slider(\"n\", \"Number of points\", min=1, max=20, value=10),\n    ),\n    ui.output_plot(\"plot\"),\n)\n\ndef server(input, output, session):\n    @render.plot\n    def plot():\n        plt.scatter(range(input.n()), range(input.n()))\n\napp = App(app_ui, server)\nSome things to notice:\n\nIn the Core app, we first used the page-level component ui.page_sidebar(), and nested inside of that, a ui.sidebar().\nIn the Express app, we created a sidebar using with ui.sidebar(). (Under the hood, this component tells Shiny Express that the parent page component is ui.page_sidebar()).\nNotice that with the Express app used express.ui.sidebar(), while the Core app used ui.sidebar(). These are not quite the same thing – the function in express.ui is actually a special wrapper for the function in ui which can be used as a context manager – that is it can be used with with."
  },
  {
    "objectID": "index.html#motivation",
    "href": "index.html#motivation",
    "title": "Shiny Express: Basics",
    "section": "Motivation",
    "text": "Motivation\nWith Shiny Express, our hope is to introduce a gentler simplicity/power tradeoff, that is nearly as easy as Streamlit but 1) not nearly as limited, and 2) leads you most of the way to Shiny Core."
  },
  {
    "objectID": "index.html#caveats",
    "href": "index.html#caveats",
    "title": "Shiny Express: Basics",
    "section": "Caveats",
    "text": "Caveats\nWhile we believe that Shiny Express will turn out to be an effective tool for those new to Shiny, we also believe that it will not be appropriate for all use cases–hence our continuing belief in the Shiny Core model. A recurring theme you will find in the finer points below is that Shiny Express is easier to write but harder to manipulate and reason about, while Shiny Core demands more up-front learning and some small inconveniences in return for being easier to read and reason about as your apps get larger.\nWe also want to acknowledge the inherent risk of introducing a second (or depending on how you count, also a third and fourth!) way of writing Shiny apps. One risk is that Shiny Express will lead users into a learning cul-de-sac that is then harder to grow out of (and into Shiny Core) than if they had just learned Shiny in the first place–as we see Streamlit users cling to it long after they have left the domain where Streamlit works well. Another risk is that having two ways of doing things is just going to be confusing (see Panel, or on the mostly-positive side, Matplotlib)."
  },
  {
    "objectID": "index.html#differences-between-express-and-core",
    "href": "index.html#differences-between-express-and-core",
    "title": "Shiny Express: Basics",
    "section": "Differences between Express and Core",
    "text": "Differences between Express and Core\nThe main differences between Shiny Express and Core are the following:\n\nThere is no separation between UI and server code. The UI and server code is mixed together.\nIn Shiny Express, UI components can be nested by writing with ui.xx(), where ui.xx() is a component that can contain other UI elements. In Shiny Core, you use nested function calls, like ui.xx(ui.yy()).\nShiny Express apps have from shiny.express import ..., import shiny.express, or from shiny import express. The presence of any of these statements tells Shiny that the app should be run in Express mode.\n\n\nNo separation between UI and server code\nIn Core, UI and server logic are declared separately, with the UI containing ui.output_xxx objects to indicate where each output goes and the server containing the logic in a @render.xx function indicating what each output is.\n#| standalone: true\n#| components: [editor, viewer]\n# Core\nfrom shiny import ui, render, reactive, App\nfrom datetime import datetime\n\napp_ui = ui.page_fixed(\n    ui.h1(\"Title\"),\n    ui.output_code(\"greeting\"),\n)\n\ndef server(input, output, session):\n    @reactive.Calc\n    def time():\n        reactive.invalidate_later(1)\n        return datetime.now()\n\n    @render.code\n    def greeting():\n        return f\"Hello, world!\\nIt's currently {time()}.\"\n\napp = App(app_ui, server)\nIn Shiny Express, the top level of the Python file can contain both UI expressions and server declarations, in any order. By default, declaring a render function causes it to appear right in that spot.\n#| standalone: true\n#| components: [editor, viewer]\n# Express\nfrom shiny import ui, render, reactive, App\nimport shiny.express\nfrom datetime import datetime\n\nui.h1(\"Title\")\n\n@reactive.Calc\ndef time():\n    reactive.invalidate_later(1)\n    return datetime.now()\n\n@render.code\ndef greeting():\n    return f\"Hello, world!\\nIt's currently {time()}.\"\nNotice how greeting in this app does not have a corresponding call to output_code(\"greeting\"). This is because in Shiny Express, the render functions automatically invoke that output function and add it to the page – no need to do it manually.\n\nExpress advantages:\n\nIt’s nice for beginners not to have to learn about the difference between UI and server.\nAvoids having to write code in two different places for a single output, and having to make the IDs match up.\nNo need to write nested function declarations (i.e. functions inside the server function), which can be surprising to Python programmers.\n\n\n\nCore advantages:\n\nUI structure is clearer to read, reorder, and restructure. This advantage grows as app UIs grow larger.\nExplicit server function declaration gave us a natural place to put code that should only execute at startup (top level) versus for each session (server function body).\n\n\n\n\nContainer components using with ui.xx()\nBroadly speaking, there are two kinds of UI components in Shiny: container components, which, as the name suggests, contain other components, and non-container components, which don’t. (You can also think of the UI as a tree data structure; container components have children, while non-container components are leaf, or terminal nodes in the tree.)\nHere are some examples of container components:\n\nsidebar()\ncard()\nlayout_columns()\ndiv()\n\nHere are some examples of non-container components:\n\ninput_text()\noutput_plot()\n\nIn Shiny Core, all components are available from the ui submodule, for example, ui.sidebar(), and ui.input_text(), and to nest the components, you nest the function calls, like ui.sidebar(ui.input_text()). You might create a simple app UI like this:\n#| standalone: true\n#| components: [editor, viewer]\n#| layout: vertical\n# Core\nfrom shiny import ui, render, App\n\napp_ui = ui.page_sidebar(\n    ui.sidebar(\n        ui.input_text(\"txt_in\", \"Type something here:\"),\n        fg=\"white\",\n        bg=\"black\",\n    ),\n    ui.card(\n        ui.output_code(\"result\"),\n    )\n)\n\ndef server(input, output, session):\n    @render.code\n    def result():\n        return f\"You entered '{input.txt_in()}'.\"\n\napp = App(app_ui, server)\nIn Express apps, there are the following differences:\n\nInstead of from shiny import ui, you use from shiny.express import ui. (Almost all functions from shiny.ui have corresponding functions in shiny.express.ui.)\nThere’s no need to call page_sidebar() – if you simply use ui.sidebar(), Shiny will infer that it needs to use page_sidebar().\nContainer components, like ui.sidebar() are context managers, and used via with ui.sidebar(). Their child components go within the with block.\nYou can put the server code (like @reactive.calc and @render.code) inside of the with statement blocks.\n\n#| standalone: true\n#| components: [editor, viewer]\n#| layout: vertical\n# Express\nfrom shiny import render, App\nfrom shiny.express import input, ui\n\nwith ui.sidebar(fg=\"white\", bg=\"black\"):\n    ui.input_text(\"txt_in\", \"Type something here:\")\n\nwith ui.card():\n    @render.code\n    def result():\n        return f\"You entered '{input.txt_in()}'.\"\nIn Shiny Express, container components are usually used as context managers, using with.\n\n\n\n\n\n\nNote\n\n\n\nIn unusual situations, you might want to create HTML content that doesn’t use context managers. HTML tag functions, like div() and span() can actually be used as context managers or as regular functions, so the following are equivalent:\n#| standalone: true\n#| components: [editor, viewer]\n#| layout: vertical\n# Express\nfrom shiny.express import ui\n\nwith ui.div():\n    with ui.pre(style=\"background-color: #eff;\"):\n        \"Hello!\"\n\nui.div(\n    ui.pre(\n        \"Hello!\",\n        style=\"background-color: #eff;\",\n    ),\n)\nMore complex component functions, such as sidebar() and card(), can only be used as context managers.\n\n\n\n\nPage-level containers and options\nIn a Core app, the UI always has a top-level page_ container, like page_fluid(), page_fillable(), or page_sidebar().\nWith Shiny Express, you normally don’t have to think about which page_ function to use.\nInstead of you deciding which specific page_ function to use, Shiny decides, based on:\n\nThe contents of the page – for example, if there is a sidebar() at the top level, it will automatically use page_sidebar().\nOptions that have been set with the page_opts() function.\n\nThe page_opts() function can be used to set the title of the page, as well as the filling behavior of the contents.\npage_opts(\n    title=\"Data app\",\n    fillable=True\n)\nWith page_opts(fillable=False), the contents of the page will display at their “natural” size. For example, with a plot, the default height is 400 pixels. If there is more content than fits in the window, a scroll bar will show up.\n#| standalone: true\n#| components: [viewer]\n#| layout: vertical\n#| viewerHeight: 300\nimport matplotlib.pyplot as plt\nfrom shiny import render\nfrom shiny.express import input, ui\n\nui.page_opts(fillable=False)\n\nwith ui.sidebar():\n    ui.input_slider(\"n\", \"Number of points\", min=1, max=20, value=10)\n\nwith ui.pre():\n    \"ui.page_opts(fillable=False)\"\n\n@render.plot\ndef plot():\n    plt.scatter(range(input.n()), range(input.n()))\nWith page_opts(fillable=True), the contents will try to scale to fit the window, so that no scroll bar will be present. Some components, like plots, are “flexy” and can stretch to fit; other components, like text, are not flexy, and will stay their natural size.\n#| standalone: true\n#| components: [viewer]\n#| layout: vertical\n#| viewerHeight: 300\nimport matplotlib.pyplot as plt\nfrom shiny import render\nfrom shiny.express import input, ui\n\nui.page_opts(fillable=True)\n\nwith ui.sidebar():\n    ui.input_slider(\"n\", \"Number of points\", min=1, max=20, value=10)\n\nwith ui.pre():\n    \"ui.page_opts(fillable=True)\"\n\n@render.plot\ndef plot():\n    plt.scatter(range(input.n()), range(input.n()))\n\n\n\n\n\n\nNote\n\n\n\nThese settings for page_opts() are passed to the shiny.ui.page_auto() function."
  },
  {
    "objectID": "index.html#deploying-shiny-express-apps",
    "href": "index.html#deploying-shiny-express-apps",
    "title": "Shiny Express: Basics",
    "section": "Deploying Shiny Express apps",
    "text": "Deploying Shiny Express apps\nTo deploy Shiny Express apps on a Connect server or shinyapps.io, you will need to install rsconnect-python 1.22.0 or later:\npip install rsconnect-python --upgrade\nYou will also need to provide a requirements.txt file which tells the server to install htmltools and shiny from GitHub:\n# requirements.txt\nhtmltools@git+https://github.com/posit-dev/py-htmltools.git@main\nshiny@git+https://github.com/posit-dev/py-shiny.git@main\nThen deploy the app as usual. If you are in the directory containing the app, use the following command, replacing &lt;server name&gt; with the nickname for your server.\nrsconnect deploy shiny . -n &lt;server name&gt;"
  }
]